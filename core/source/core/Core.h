#pragma once

#include <array>
#include <cmath>
#include <cstddef>
#include <functional>
#include <queue>
#include <thread>
#include <vector>
namespace crbn
{

void start_sim();

typedef double coord_type;

struct pos
{
    coord_type x, y;
};

struct particle_2d
{
    coord_type mass = 0;
    coord_type vel_y = 0;
    coord_type vel_x = 0;
    coord_type xpos = 0;
    coord_type ypos = 0;
    coord_type radius = 1;
    int8_t out_of_bounds = 0;
};

class Uniform_Sphere_Sim_2d
{
public: // Public callable functions :
    // Called to run a single "frame" of the simulation.
    // Maby it will be async?
    void runAsync(const float& elapsedTime);

    // Gets the coord buf generated by the current async process.
    // If the async Thread isnt finished, then it will stall till it is
    coord_type* getCoordBuf();

    // Does what it says, sets the ammount of particles
    // Returns the size of the particle array which has DOUBLE the NUMBER OF ELEMENTS (NOT BYTES)
    // particle count
    size_t setParticleCount(const size_t& particles);

    void setParticle(const particle_2d& part, const size_t& element);
    void setTimeModifier(const coord_type& time_modifier);

    Uniform_Sphere_Sim_2d();
    ~Uniform_Sphere_Sim_2d();

    /// Sets a modifier that speeds up or slows down simulation speed
    coord_type _time_modifier;
    /// Sets the decimal percentage of total energy after a bounce with a wall?
    coord_type _bounce_losses;
    /// Sets the (x,y)(x,y) of the top left and bottom right dimensions of the rectangular container
    std::array<int, 4> _rectangle_dims {};
    enum _rectangle_array
    {
        bottom_left_x = 0,
        bottom_left_y,
        top_right_x,
        top_right_y,
    };
    /// The ammount of divisions to split up screen
    std::pair<int, int> _chunks;

    bool async;
    int threads;
    float gravity = -9.81;

private: // Member Variables
    std::vector<coord_type> _coordinate_array;
    std::size_t _coordinate_array_size;
    bool _coords_ready;
    size_t _particle_count;
    std::vector<particle_2d> _particles;

    // temporary :

private: // Member Functions
    void dirtyCollisionDetector();

public:
};

static void dirtyColliderProcess(std::vector<particle_2d*>& particles);

class Thread_Worker
{
public:
    Thread_Worker();
    void sendJobs(std::queue<std::function<void>>&);
    void setup(int workers);
    void sleepWorkers(bool sleeping = true);
    bool areJobsDone();

    std::vector<std::thread> _workers;
    std::vector<std::queue<std::function<void>>*> _data;
    int _worker_count;
};

}
